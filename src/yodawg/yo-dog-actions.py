from robocorp import browser
from sema4ai.actions import action, Response, ActionError
import os
from .image_generation import YoDawgImageGenerator
from .models import YoDawgResponse
import time
import dotenv
from typing import Optional

dotenv.load_dotenv()

LINKEDIN_USERNAME = os.getenv("LINKEDIN_USERNAME")
LINKEDIN_PASSWORD = os.getenv("LINKEDIN_PASSWORD")




@action
def comment_on_linkedin_post_with_image(
    post_url: Optional[str] = None,
    custom_context: Optional[str] = None,
    append_custom_context: bool = False
) -> Response:
    """
    Generate and post a Yo Dawg meme comment on LinkedIn using one of three modes:
    1. Only LinkedIn post content (provide post_url)
    2. Only custom context (provide custom_context)
    3. LinkedIn post content with appended custom context (provide both, set append_custom_context=True)
    
    :param post_url: The URL of the LinkedIn post to comment on.
    :param custom_context: Optional custom context string for meme generation.
    :param append_custom_context: If True, append custom context to LinkedIn post content.
    """
    # Enforce input logic
    meme_context = None
    if append_custom_context:
        if not post_url or not custom_context:
            raise ActionError("Both post_url and custom_context must be provided when append_custom_context is True.")
    elif custom_context and not post_url:
        meme_context = custom_context
    elif post_url and not custom_context:
        meme_context = None  # Will be set after fetching post content
    elif post_url and custom_context:
        raise ActionError("If you want to append custom context, set append_custom_context=True. Otherwise, provide only one.")
    else:
        raise ActionError("You must provide either post_url, custom_context, or both with append_custom_context=True.")

    if post_url:
        configure_browser()
        page = browser.goto(post_url)
        post_content = get_linkedin_post_content(page)
        if append_custom_context:
            meme_context = f"{post_content}\n\n{custom_context}"
        else:
            meme_context = post_content
    
    if not meme_context:
        raise ActionError("No context available for meme generation.")
    # Generate meme
    yo_dawg_response = yo_dawg_generator(meme_context)
    image_path = yo_dawg_response.image_filename
    
    signature = "\n\n---\nðŸŽ¯ This content was generated by The Yo Dawg Sema4ai Action Server\nðŸ“¡ Powered by Model Context Protocol (MCP)\nðŸ¤– Autonomous meme generation system active"
    comment_text = signature
    
    if post_url:
        # Click on the comment box
        page.get_by_role("textbox", name="Text editor for creating").get_by_role("paragraph").click()
        # Add image if provided
        if image_path and os.path.exists(image_path):
            print(f"Uploading image: {image_path}")
            try:
                with page.expect_file_chooser() as fc_info:
                    page.locator("button[aria-label*='photo']").click()
                file_chooser = fc_info.value
                file_chooser.set_files(image_path)
                page.wait_for_selector("img[alt*='Image preview']", timeout=10_000)
                print("Image uploaded and preview is visible.")
            except Exception as e:
                print(f"Could not upload image: {str(e)}")
        else:
            print(f"Image not found or path empty: {image_path}")
        # Add the comment text
        page.get_by_role("textbox", name="Text editor for creating").fill(comment_text)
        # Submit the comment
        print("Submitting comment...")
        page.locator("button[class^='comments-comment-box__submit-button']").click()
        time.sleep(10)
        page.close()
        result_message = f"Commented on post: {post_url}"
        if image_path:
            result_message += f" with image: {image_path}"
        result_message += f" (Generated Yo Dawg meme)"
    else:
        result_message = f"Generated Yo Dawg meme with custom context only."
        if image_path:
            result_message += f" Image: {image_path}"
    return Response(result=result_message)


def get_linkedin_post_content(page) -> str:
    """
    Get the content text from a LinkedIn post page.
    
    :param page: The browser page object already navigated to the LinkedIn post.
    :return: The post content as a string.
    """
    try:
        # Try to find the main post content - updated selector
        post_content = page.locator(".update-components-text").first.inner_text()
        return post_content
    except Exception as e:
        # Fallback selectors
        try:
            post_content = page.locator("[data-test-id='main-feed-activity-card'] .feed-shared-text").first.inner_text()
            return post_content
        except Exception as e2:
            try:
                post_content = page.locator(".feed-shared-text").first.inner_text()
                return post_content
            except Exception as e3:
                return "this post"  # fallback content


def yo_dawg_generator(
    yo_dawg_content: str,
) -> YoDawgResponse:
    """
    A 'Yo Dawg' action that generates a meme caption and image.
    """
    try:
        if not yo_dawg_content:
            raise ActionError("No content provided for meme generation.")

        generator = YoDawgImageGenerator()
        yo_caption = generator.generate_yo_dawg_quote(yo_dawg_content)
        if not yo_caption:
            raise ActionError("Failed to generate Yo Dawg caption.")

        images_dir = "yo-dawg-images"
        if not os.path.exists(images_dir):
            os.makedirs(images_dir)
        unique_filename = f"yo_dawg_image_{int(time.time())}.png"
        image_path = os.path.join(images_dir, unique_filename)
        generator.generate_image(yo_caption, image_path)

        return YoDawgResponse(caption=yo_caption, image_filename=image_path)
    except Exception as e:
        raise ActionError(f"An error occurred: {str(e)}")



def configure_browser():
    browser.configure(
        screenshot="only-on-failure",
        headless=False,
        persistent_context_directory=os.path.join(os.getcwd(), "browser_context"),

    )



def _login(page, username, password):
    page.get_by_role("textbox", name="Email or phone").fill(username)
    page.get_by_role("textbox", name="Password").fill(password)
    page.get_by_role("button", name="Sign in", exact=True).click()

def _is_authenticated(page):
    # Try to find an element that only appears when logged in, e.g., the profile avatar or "Me" menu
    try:
        # This selector may need adjustment based on LinkedIn's DOM
        page.get_by_role("navigation").get_by_text("Me", exact=True, timeout=3000)
        return True
    except Exception:
        return False
